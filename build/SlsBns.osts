//////////////////////////////////////////////////////
//                                                  //
//                  Created By:                     //
//                Matthew Beckwith                  //
//                                                  //
//                   April 2025                     //
//                                                  //
//////////////////////////////////////////////////////

function main(workbook: ExcelScript.Workbook) {
    const initialSheets = workbook.getWorksheets();

    const lookup = {};
    const reports = {};

    initialSheets.map(sheet => {
        const sheetName = sheet.getName();
        const data = sheet.getUsedRange().getValues();
        if (sheetName.includes("-")) {
            const splitName = sheetName.split("-");
            if (splitName.length > 1) {
                const typeOfReport = splitName[0].trim().toLowerCase(); // In case we need more control
                const reportName = splitName[1].trim().toLowerCase();
                lookup[reportName] = new LookupReport(data);
            }
        } else {
            switch (sheetName) {
                case "INPUT": reports["globals"] = new InputReport(data);
                    break;
                case "0432": reports["deals"] = new DealsReport(data);
                    break;
                case "90": reports["averageunits"] = new AverageUnitReport(data);
                    break;
                case "3213": reports["priordraw"] = new PriorDrawReport(data);
                    break;
                case "SPIFFS": reports["spiffs"] = new SpiffReport(data);
                    break;
                case "NpsSheet":
                    const head = data[2];
                    const body = data.slice(3)
                    reports["nps"] = new NpsReport([head, ...body]);
                    break;
                default:
                    sheet.delete();
                    break;
            }
        }
    });

    const { storeName, storeAbbr, date, regionalScore, topsalesAmount, ...accounts }: Store = reports["globals"].vars;
    const { retroAcct, expenseAcct1, expenseAcct2, salesTaxAcct, salesBonusAcct1, salesBonusAcct2 }: AccountNumbers = accounts;
    const accountNumbers: AccountNumbers = { retro: retroAcct, expense1: expenseAcct1, expense2: expenseAcct2, salesTax: salesTaxAcct, salesBonus1: salesBonusAcct1, salesBonus2: salesBonusAcct2 }
    const store: Store = {
        name: storeName, abbr: storeAbbr, displayDate: date, employees: [],
        regionalScore: regionalScore, topsalesAmount, accountNumbers
    };

    const employeeList = getAllEmployees(reports);
    attachSpiffs(reports["spiffs"].list, employeeList);
    attachNps(reports["nps"].list, employeeList, store.regionalScore);
    attachPriorDraw(reports["priordraw"].list, employeeList);
    attachUnits(reports["averageunits"].list, employeeList);
    attachDeals(reports["deals"].list, employeeList);
    calculateRetro(lookup["retromini"], lookup["retropercentage"], employeeList);
    calculateUnitBonus(lookup["unit"], employeeList);
    caclulateNpsBonus(regionalScore, employeeList);

    store.employees = employeeList;
    console.log(store);
}


function getAllEmployees(reports: InputReport | DealsReport | AverageUnitReport | PriorDrawReport | SpiffReport | NpsReport) {
    const allEmps: Employee[] = [];
    for (const [key, val] of Object.entries(reports)) {
        switch (key) {
            case "globals":
            case "spiffs":
                break;
            default:
                val.list.map(v => {
                    const employee = allEmps.filter(emp => emp.id === v.employeeID)[0];
                    const nps = new Nps();
                    const averageUnits = new AverageUnits(0);
                    const units = new Units();
                    if (!employee) allEmps.push({ id: v.employeeID, name: v.employeeName, deals: [], nps, spiffsTotal: 0, priorDraw: 0, retroPercent: 0, bonus: { unit: 0, topsales: 0, nps: 0 }, averageUnits, units });
                });
                break;
        }
    }
    return allEmps;
}


function attachSpiffs(spiffs: EmployeeSpiff[], employeeList: Employee[]) {
    spiffs.forEach(spiff => {
        employeeList.filter(emp => emp.id === spiff.employeeID)[0].spiffsTotal = spiff.amount;
    });
}


function attachNps(npsList: EmployeeNps[], employeeList: Employee[], regionalScore: number) {
    npsList.forEach(nps => {
        const employee = employeeList.filter(emp => emp.id === nps.employeeID)[0];
        employee.nps.surveyCount = nps.surveyCount;
        employee.nps.averagePercent = nps.averagePercent;
        employee.nps.currentPercent = nps.currentPercent;
    });
}


function attachPriorDraw(pd: PriorDraw[], employeeList: Employee[]) {
    pd.forEach(d => {
        employeeList.filter(emp => emp.id === d.employeeID)[0].priorDraw = d.draw;
    });
}


function attachUnits(units: EmployeeUnits[], employeeList: Employee[]) {
    units.forEach(unit => {
        const employee = employeeList.filter(emp => emp.id === unit.employeeID)[0];
        employee.averageUnits.threeMonthCount = unit.count;
    });
}


function attachDeals(deals: DealRow[], employeeList: Employee[]) {
    employeeList.forEach(employee => {
        employee.deals = deals.filter(emp => emp.employeeID === employee.id).map(deal => {
            employee.units[deal.vehicleType.toLowerCase()] += deal.dealUnitCount;
            return {
                id: deal.dealID,
                customer: { id: deal.customerID, name: deal.customerName },
                vehicle: new Vehicle(deal.vehicleID, deal.vehicleDescription, deal.vehicleType),
                unitCount: deal.dealUnitCount,
                commission: { fni: deal.commissionFnI, gross: deal.commissionGross, amount: deal.commissionAmount },
                retro: new Retro()
            }
        });
    });
}


function calculateRetro(retroMiniLookup: LookupReport, retroPercentLookup: LookupReport, employeeList: Employee[]) {
    employeeList.forEach(employee => {
        employee.retroPercent = retroPercentLookup.getValue(employee.units.getTotal());
        employee.deals.forEach(deal => {
          const dealRetro = new Retro();
          dealRetro.calculateMini(retroMiniLookup, deal.commission.amount, employee.averageUnits.getAverage(), deal.unitCount);
          dealRetro.calculateOwed(deal.commission.amount);
          dealRetro.calculatePayout(deal.commission.gross, employee.retroPercent);
            deal.retro = dealRetro;
        });
    });
}


function calculateUnitBonus(unitBonusLookup: LookupReport, employeeList: Employee[]) {
    employeeList.forEach(employee => {
        employee.bonus.unit = unitBonusLookup.getValue(employee.units.getTotal());
    });
}

function caclulateNpsBonus(regionalScore: number, employeeList: Employee[]) {
    employeeList.forEach(employee => {
        const unitCount = employee.units.getTotal();
        employee.bonus.nps = employee.nps.getBonus(unitCount, regionalScore);
    });
}

interface Store {
    name: string;
    abbr: string;
    displayDate: string;
    employees: Employee[];
    regionalScore: number;
    topsalesAmount: number;
    accountNumbers: AccountNumbers;
}

interface AccountNumbers {
    retro: string;
    expense1: string;
    expense2: string;
    salesTax: string;
    salesBonus1: string;
    salesBonus2: string;
}

interface Employee {
    id: number;
    name: string;
    deals: Deal[];
    nps: Nps;
    spiffsTotal: number;
    priorDraw: number;
    retroPercent: number;
    bonus: Bonus;
    averageUnits: AverageUnits;
    units: Units;
}

interface Deal {
    id: string;
    customer: {
        id: number;
        name: string;
    };
    vehicle: Vehicle;
    unitCount: number;
    commission: Commission;
    retro: Retro;
}

interface Commission {
    fni: number;
    gross: number;
    amount: number;
}

interface Bonus {
    unit: number;
    topsales: number;
    nps: number;
}

interface LookupRow {
    min: number;
    max: number;
    val: number;
}

interface StoreVars {
    storeName: string;
    storeAbbr: string;
    date: string;
    regionalScore: number;
    topsalesmanBonusAmount: number;
    retroAcct: string;
    expenseAcct1: string;
    expenseAcct2: string;
    salesTaxAcct: string;
    salesBonusAcct1: string;
    salesBonusAcct2: string;
}

interface EmployeeUnits {
    employeeID: number;
    employeeName: string;
    count: number;
    average: number;
}

interface PriorDraw {
    employeeID: number;
    employeeName: string;
    commission: number;
    draw: number;
}

interface EmployeeSpiff {
    employeeID: number;
    amount: number;
}

interface DealRow {
    date: number;
    dealID: string;
    employeeID: number;
    employeeName: string;
    customerID: number;
    customerName: string;
    vehicleID: string;
    vehicleDescription: string;
    vehicleType: string;
    commissionFnI: number;
    commissionGross: number;
    dealUnitCount: number;
    commissionAmount: number;
}

interface EmployeeNps {
    employeeID: number;
    employeeName: string;
    surveyCount: number;
    currentPercent: number;
    averagePercent: number;
}

class LookupReport {
    public rows: LookupRow[];
    constructor(private data: Array<string | number | boolean>[]) {
        this.rows = [];
        data.map((d, i) => {
            const next = data[i + 1];
            const max = next ? Number(data[i + 1][0]) : 100000000000;
            this.rows.push({ min: Number(d[0]), max, val: Number(d[1]) });
        });
    }
    getValue(query: number) {
        if (this.rows.some(row => query >= row.min && query < row.max)) return this.rows.filter(row => query >= row.min && query < row.max)[0].val;
        return 0;
    }
}

class Units {
    public new: number;
    public used: number;
    constructor() {
        this.new = 0;
        this.used = 0;
    }
    calculatePercent(): object {
        const total = this.getTotal();
        return {
            new: this.new / total,
            used: this.used / total
        };
    }
    getTotal(): number {
        return this.new + this.used;
    }
    getBonus(unitBonusLookup: LookupReport) {
        const total = this.getTotal();
        return unitBonusLookup.getValue(total);
    }
}

class AverageUnits {
    constructor(public threeMonthCount: number) { }
    getAverage(): number {
        return Math.round(this.threeMonthCount / 3);
    }
}

class Vehicle {
    public year: number;
    public make: string;
    public model: string;
    public desc: string;
    constructor(public id: string, private description: string, public saleType: string) {
        this.id = id;
        this.saleType = saleType;

        const data = description.split(',');
        this.year = Number(data[0]);
        this.make = String(data[1]);
        this.model = String(data[2]);
        this.desc = String(data[3]);
    }
}

class Retro {
    public mini: number;
    public owed: number;
    public payout: number;
    constructor() {
        this.mini = 0;
        this.owed = 0;
        this.payout = 0;
    }
    calculateMini(retroMiniLookup: LookupReport, dealCommissionAmount: number, employeeAverageUnits: number, dealUnitCount: number) {
        this.mini = dealCommissionAmount <= 251 ? retroMiniLookup.getValue(employeeAverageUnits) * dealUnitCount : 0;
    }
    calculateOwed(dealCommissionAmount: number) {
        this.owed = this.mini > 0 ? this.mini - dealCommissionAmount : 0;
    }
    calculatePayout(dealCommissionGross: number, employeeRetroPercent) {
        this.payout = this.mini === 0 ? dealCommissionGross * employeeRetroPercent : 0;
    }
    getPercent(retroPercentLookup: LookupReport, employeeUnitCount: number): number {
        return retroPercentLookup.getValue(employeeUnitCount);
    }
    getTotal(): number {
        return this.owed + this.payout;
    }
}


class Nps {
    public surveyCount: number;
    public currentPercent: number;
    public averagePercent: number;
    constructor() {
        this.surveyCount = 0;
        this.currentPercent = 0;
        this.averagePercent = 0;
    }
    getBonus(dealUnitCount: number, regionalScore: number): number {
        const outcome = this.getOutcome(regionalScore);
        if(outcome === '3P') return dealUnitCount * 50;
        if(outcome === 'B') return dealUnitCount * -50;
        return 0;
    }
    getOutcome(regionalScore: number) {
        const score = (this.currentPercent > this.averagePercent ? this.currentPercent : this.averagePercent) * 100;
        const buffed = regionalScore + 0.03;
        if(score >= buffed) return '3P';
        if(score === regionalScore) return 'A';
        return 'B';
    }
}

class Report {
    private header: Array<string | number | boolean>;
    constructor(protected data: Array<string | number | boolean>[]) {
        this.header = data.shift();
        this.data = data;
    }
    getColumn(columnLabel: string): number {
        return this.header.indexOf(columnLabel);
    }
    getValue(columnLabel: string, rowIndex: number = 0): string | number | boolean {
        return this.data[rowIndex][this.getColumn(columnLabel)];
    }
}

class InputReport extends Report {
    public vars: StoreVars;
    constructor(protected data: Array<string | number | boolean>[]) {
        super(data);
        this.vars = {
            storeName: String(this.getValue("Store Name")),
            storeAbbr: String(this.getValue("Store Abbr")),
            date: String(this.getValue("Date")),
            regionalScore: Number(this.getValue("Regional Score")),
            topsalesmanBonusAmount: Number(this.getValue("Topsalesman Bonus")),
            retroAcct: String(this.getValue("Retro Acct")),
            expenseAcct1: String(this.getValue("Expense 1 Acct")),
            expenseAcct2: String(this.getValue("Expense 2 Acct")),
            salesTaxAcct: String(this.getValue("Sales Tax Acct")),
            salesBonusAcct1: String(this.getValue("Sales Bonus Tax 1")),
            salesBonusAcct2: String(this.getValue("Sales Bonus Tax 2")),
        }
    }
}

class AverageUnitReport extends Report {
    public list: EmployeeUnits[];
    constructor(protected data: Array<string | number | boolean>[]) {
        super(data);
        this.list = [];
        this.data.map((d, i) => {
            const employeeID = Number(this.getValue("Salesperson#", i));
            const employeeName = String(this.getValue("Salesperson Name", i));
            const count = Number(this.getValue("units", i));
            const average = Number((count / 3).toFixed(1));
            this.list.push({ employeeID, employeeName, count, average });
        });
    }
}

class PriorDrawReport extends Report {
    public list: PriorDraw[];
    constructor(protected data: Array<string | number | boolean>[]) {
        super(data);
        this.list = [];
        this.data.map((d, i) => {
            const employeeID = Number(this.getValue("Control#", i));
            const employeeName = String(this.getValue("Description", i));
            const commission = Number(this.getValue("8321C", i));
            const draw = Number(this.getValue("8321D", i));
            this.list.push({ employeeID, employeeName, commission, draw });
        });
    }
}

class SpiffReport extends Report {
    public list: EmployeeSpiff[];
    constructor(protected data: Array<string | number | boolean>[]) {
        super(data);
        this.list = [];
        this.data.map((d, i) => {
            const employeeID = Number(this.getValue("Employee #", i));
            const amount = Number(this.getValue("Total", i));
            if (employeeID > 0) this.list.push({ employeeID, amount });
        });
    }
}

class DealsReport extends Report {
    public list: DealRow[];
    constructor(protected data: Array<string | number | boolean>[]) {
        super(data);
        this.list = [];
        this.data.map((d, i) => {
            const date = Number(this.getValue("Date", i));
            const dealID = String(this.getValue("Reference#", i));
            const employeeID = Number(this.getValue("Salesperson#", i));
            const employeeName = String(this.getValue("Salesperson Name", i));
            const customerID = Number(this.getValue("Customer#", i));
            const customerName = String(this.getValue("Customer Name", i));
            const vehicleID = String(this.getValue("Stock#", i));
            const vehicleDescription = String(this.getValue("Description", i));
            const vehicleType = String(this.getValue("Sale Type", i));
            const commissionFnI = Number(this.getValue("COMMBL F&I", i));
            const commissionGross = Number(this.getValue("COMMBL FRONT", i));
            const dealUnitCount = Number(this.getValue("Units", i));
            const commissionAmount = Number(this.getValue("Commission Amount", i));
            if (dealUnitCount > 0) this.list.push({ date, dealID, employeeID, employeeName, customerID, customerName, vehicleID, vehicleDescription, vehicleType, commissionFnI, commissionGross, dealUnitCount, commissionAmount });
        });
    }
}

class NpsReport extends Report {
    public list: EmployeeNps[];
    constructor(protected data: Array<string | number | boolean>[]) {
        super(data);
        this.list = [];
        this.data.map((d, i) => {
            const employeeID = Number(this.getValue("Employee #", i));
            const employeeName = String(this.getValue("BMWNC TEAM", i));
            const surveyCount = Number(this.getValue("PROMOTER", i));
            const currentPercent = Number(this.getValue("NPS%", i));
            const averagePercentCol = 23; // Not Ideal, need a better way to get this number
            const averagePercent = Number(d[averagePercentCol]);
            if (employeeID > 0) this.list.push({ employeeID, employeeName, surveyCount, currentPercent, averagePercent });
        });
    }
}

